{
    local systemslab = self,

    local invalidType(variable, expected, actual) =
        'invalid type for parameter `%(variable)s`. Expected %(expected)s, got %(actual)s instead' % {
            variable: std.toString(variable),
            expected: std.toString(expected),
            actual: std.toString(actual),
        },
    local checkOptType(variable, expected) = variable == null || std.type(variable) == expected,

    // Create a barrier step.
    //
    // Barriers allow you to synchronize multiple systemslab jobs. It works almost exactly like a
    // barrier would when using multiple threads: jobs queue up at the barrier until they've all
    // reached it and then they all get released at once.
    //
    // The arguments for this function are:
    // - `name` - The name that uniquely identifies this barrier within the experiment.
    // - `timeout` - A timeout, in seconds, after which if the barrier is not ready then the
    //    barrier action will fail. By default, the timeout is 3600 seconds.
    // - `id` - Assign a unique ID to this step.
    barrier(name, timeout=null, id=null)::
        assert std.isString(name) : invalidType('name', 'string', std.type(name));
        assert checkOptType(timeout, 'number') : invalidType('timeout', 'number', std.type(timeout));
        assert checkOptType(id, 'string') : invalidType('id', 'string', std.type(id));

        std.prune({
            uses: 'systemslab/barrier',
            id: id,
            with: {
                name: name,
                timeout: timeout,
            },
        }),

    // Create a shell step.
    //
    // The shell step allows you to run a script using a system shell (e.g. bash, sh, zsh, etc.).
    // It can also be used with any program that can read a script via stdin (e.g. python).
    //
    // The arguments for this function are:
    // - `shell`      - The shell binary to use. This will be found using the $PATH of the agent.
    // - `command`    - The contents of the script to run. This will be passed to the stdin of the
    //                  shell program.
    // - `id`         - Assign a unique ID to this step.
    // - `background` - Run this step in the background. This means that future steps will not wait
    //                  for this one to complete before starting. Note that the agent will also not
    //                  wait for this step to complete once all subsequent steps have completed.
    shell(shell, command, id=null, background=null)::
        assert std.isString(shell) : invalidType('shell', 'string', std.type(shell));
        assert std.isString(command) : invalidType('command', 'string', std.type(command));
        assert checkOptType(id, 'string') : invalidType('id', 'string', std.type(id));
        assert checkOptType(background, 'boolean') : invalidType('background', 'boolean', std.type(background));

        std.prune({
            uses: 'systemslab/shell',
            id: id,
            background: background,
            with: {
                shell: shell,
                run: command,
            },
        }),

    // Create a shell step that runs a bash script.
    //
    // This is a wrapper around `systemslab.shell` that passes in `bash` for the shell argument.
    //
    // The arguments for this function are:
    // - `command`    - The contents of the script to run. This will be passed to the stdin of the
    //                  shell program.
    // - `id`         - Assign a unique ID to this step.
    // - `background` - Run this step in the background. This means that future steps will not wait
    //                  for this one to complete before starting. Note that the agent will also not
    //                  wait for this step to complete once all subsequent steps have completed.
    bash(command, id=null, background=null)::
        systemslab.shell('bash', command, id, background),

    // Create a step to upload a file as a SystemsLab artifact.
    //
    // Uploading artifacts is the main way to store raw results generated by running a systemslab
    // experiment.
    //
    // The arguments for this function are:
    // - `path` - The path to the file that will be uploaded.
    // - `name` - The name of the artifact to be uplaoded. If not provided then the last component
    //            of `path` will be used instead.
    // - `id`   - Assign a unique ID to this step.
    // - `tags` - Artifact tags.
    upload_artifact(path, name=null, id=null, tags=null)::
        assert std.isString(path) : invalidType('path', 'string', std.type(path));
        assert checkOptType(name, 'string') : invalidType('name', 'string', std.type(name));
        assert checkOptType(id, 'string') : invalidType('id', 'string', std.type(id));
        assert checkOptType(tags, 'array') : invalidType('tags', 'array', std.type(tags));

        std.prune({
            uses: 'systemslab/upload-artifact',
            id: id,
            with: {
                path: path,
                name: name,
                tags: tags,
            },
        }),

    // Write out text to a file.
    //
    // Often, when writing an experiment, you will find it necessary to write out a config file for
    // the program you are testing. This step allows you to easily do that.
    //
    // The arguments for this function are:
    // - `path`    - The path at which to write the file. This may be either relative or absolute.
    // - `content` - The contents of the file. This can be either a string or an array of bytes.
    // - `id`      - Assign a unique ID to this step.
    write_file(path, content, id=null)::
        assert std.isString(path) : invalidType('path', 'string', std.type(path));
        assert std.isString(content) || std.isArray(content) : invalidType('content', 'string or array', std.type(content));
        assert checkOptType(id, 'string') : invalidType('id', 'string', std.type(id));

        std.prune({
            uses: 'systemslab/write-file',
            id: id,
            with: {
                path: path,
                content: content,
            },
        }),
}
